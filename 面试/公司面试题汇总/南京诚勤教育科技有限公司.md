# webpack配置

不用vue如何对less,scss进行打包，如何设置webpack

先下载加载器 css-loader和less-loader然后对每个.css文件使用css-loader

如何对每个.css文件使用css-loader，在webpack.config.js文件中设置一个规则将他暴露出去

module.exports={

​	module:{

​		rules:[

​			{test:/\.css$/,use:'css-loader'}

​			]

​	}

}

webpack常规配置项有哪些

~~~javascript
var path = require('path');
module.exports = {
  mode: 'development',
  //入口文件
  entry: './index.js',
  //输出目录
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  }
};
~~~

# 预加载和懒加载

### 1.什么是预加载？

**提前加载图片，当用户需要查看时可直接从本地缓存中渲染**

### 2.为什么要使用预加载？

图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。

### 3.实现预加载的方法有哪些？

方法一：用CSS和JavaScript实现预加载
 方法二：仅使用JavaScript实现预加载
 方法三：使用Ajax实现预加载

 

 前端性能的优化，因素或原因

# 如何解决首屏加载慢的问题

1.异步加载
 服务端渲染主 layout ，加载到客户端，通过 AJAX 获取其他页面内容，然后在客户端渲染。此种和淘宝无线 H5 的方案类似。

2.滚动异步加载
 服务端渲染首屏内容，加载到客户端，滚动时再通过 AJAX 获取次屏内容

3.分块加载
 服务端支持 chunk 输出，分块将内容传输到客户端，客户端渲染。

1和2需要通过ajax获取其余的内容，但是对首屏加载是有益的；3是最优方案，在Node中对应的是[Bigpipe](https://link.jianshu.com/?t=http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html)。 

分块传输的基本思想是：服务器产生一块数据，就发送一块，采用**流模式**(stream)取代**缓存模式**(buffer)。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了：

 this的指向

# 如何理解vue数据双向绑定原理

vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的

我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

**因此接下去我们执行以下3个步骤，实现数据的双向绑定：**

- （1）实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
- （2）实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。
- （3）实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。



provide和inject方法和vuex的区别

provide和inject方法，子组件获取的变量是随着子组件实例走的，实例存在这个变量就存在，实例销毁这个变量销毁的，不会影响其他子组件

vuex里面的变量是全局的，如果一个子组件销毁了这个变量那么其他子组件里面的变量

 

## 一. 什么是领域驱动模型(DDD)？

领域驱动模型一种设计思想，我们又称为DDD设计思想。是一种为了解决传统设计思想带来的维护困难，沟通困难和交互困难而产生的一种新的思想。也解决了在部分公司中，一个项目组就是一套服务，不同项目组中又相互通过RPC访问，相互之间交互的安全保障。

## 二. 领域驱动模型解决了什么问题

在传统微服务的单服务设计上，我们通常只顾自己开发，只顾自己业务，只管理自己数据库，一旦其他服务需要使用另一个服务上的某些功能时，我们通常需要使用HTTP来内网访问达到目的，或是使用RPC来访问业务。首先假设我们需要用HTTP来访问其他服务接口，首先，我们需要知道对应服务的URL，其次需要开发方提供对应的参数VO，一旦VO变化，开发方忘记通知下游业务方，下游业务方是无法感知的。接下来会讲解模型中每一层概念，会一步步证明领域驱动模型的出现，降低了微服务下，服务之间的耦合程度，提高了内聚力。

## 三. 设计领域驱动模型

### 传统设计模型：

![img](https://pic4.zhimg.com/80/v2-d02972e9f2cf85c286639bc77db8fc2f_720w.jpg)

### 领域驱动模型：

![img](https://pic1.zhimg.com/80/v2-e47f4866b09b7a5dfe3d695e7bea9e40_720w.jpg)

### 以下介绍的层级，即是领域驱动模型中代表的各个领域，去负责自己的范围：

### API层：

作用：存放要对外暴露的RPC接口的service层。

意义：其他服务不需要了解自身服务的业务实现，这一层很薄，只需要提供出去，其他服务知道它是干嘛的，就足够了，即让其他服务调用了自身业务，又没有暴露自身的业务实现，降低安全风险。

### Web层：

作用：可以对等于传统设计的controller层，用来处理参数校验，转发等一些简单的业务。

意义：与Service层剥离，其目的是为了保障biz层的独立性，但是在maven结构中又引用biz层，可以理解为biz的下游，当需要biz处理业务的时候，通知biz帮忙处理，但是不参与biz层的业务实现，只提交对应参数。

### Biz层：

作用：biz是Business的缩写，即业务逻辑层，可以对等于传统设计的Service层，存放的业务逻辑，biz中也存在service，biz中的service存放的是内部使用，不对外提供的service。api层和biz层的service业务逻辑实现都存放在biz层中。

意义：剥离业务逻辑，防止业务逻辑暴露，同时与dal层剥离，保证自身独立性，不与dal层耦合。这一层也是服务核心层，是处理下游提交的需求与数据之间交互的重要层级。

### dal层：

作用：dal是Data Access Layer的英文缩写，即数据访问层，可以对等于传统设计的Dao层，主要是用来负责与数据的交互，比如Mysql、ES、HBase等。通常我们的Mybatis的Mapper和JPA就在这一层编写。

意义：让业务与数据隔离，dal层成为了biz层的上游，负责为biz的业务实现提供对应数据。同时dal与数据中间件直接映射，形成绑定关系，其他服务需要接手数据层，可以直接引用，达到高内聚的目的，又降低了代码的耦合性，提高了开发效率。

### domain层：

作用：存放一些通用的，可以对外暴露的Object、Enum等。

意义：通常用来制定一些标准，比如共同使用的枚举、常量的定义，一般作为上游服务，提供给下游服务，需要按照标准实施的内容。

### config层：

作用：存放一些通用的配置，如缓存、中间件、日志和消息消费等通用配置，注意一点的是，消息消费简单的处理是放在该层，涉及到本服务数据交互的业务，还是需要写在biz层，在biz中去实现较为复杂的业务，消息消费放在该层中也是为了便于维护。

意义：配置独立化，便于管理与维护。

### client层：

作用：存放调用第三放平台，外部服务等RPC或HTTP接口服务等。如通过pom引入其他服务的api层，编写调用http接口的实现，但与本服务数据交互的业务仍在biz层中实现。

意义：第三方内容独立化，便于管理与维护。

 

#  组件化编程

## 基本概念

## 传统方式编写应用与组件化方式编写应用的对比

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e00101b5938049aba5efdb0d540b69ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbc81f657fc491a8bfd0d3692343b86~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

对比：组件化编写应用更加高效方便，比如我们不同的网站用同一个顶部组件，我们只需要引入组件即可；而传统的编写方式需要重新编写或复制html、css、js文件；相比较而言组件更好。

#  **什么是重构**

我们开发惯指的 **重构** ，一般都是指技术重构。简单点说就是基于项目进行代码层面的重构。推倒了重新来，老房子扒掉重新造，肯定是有钱了想让自己更舒适，程序代码推倒了重新写，还不是因为代码质量经过长年累月需求迭代，祖传代码越来越难维护，更别说在这个基础上去老树开花，开发一些新功能。（代码太烂，遗留的坑太多，就是程序的拓展性和维护性不好呗画外音，前浪们留下的一堆堆精华 :hankey: ，需要后狼们一铲一铲地拍在 上……）

## **那么问题来了，你的项目到底需不需要重构呢**

考虑到项目重构带来的人力、时间、项目风险等因素，在商业项目中，推倒重来是一个风险高，收益低，吃力不太讨好的事情。而且，推翻之前的项目重做，也不定会写出比以前更好的代码。那为什么还要重构呢，或许我们从业务和团队角度分析能得到一些答案。

### **业务角度分析**

1. 业务转型了，基于原有业务做得系统自然成了前朝遗老，不招人稀罕了，别说重构，废弃都是有可能的。
2. 业务体量变化，原先的技术架构可能对于百人内的团队，性能上瓶颈不明显，但是随着业务体量的上涨，对于产品性能、扩展性、稳定性的要求越来越高，会推动当前产品迭代及重构的需求

### **团队角度分析**

1. 当前技术方案的问题：单签方案是否影响团队开发效率，项目技术方案是否比较陈旧，难以维护，是否存在家属架构及依赖包过于老旧的问题。如果你的项目依赖文件人家官方都已经不维护了，而且官方文档也给出了相关替换方案，那你的项目确实该进行升级、迭代，甚至是换一套新的技术栈进行重构了。
2. 当前项目的代码本身的问题：代码是否基于团队规范标准开发，代码是否有较好的拓展性、健壮性和可维护性。项目代码经过长期迭代，多人轮换，没有规范标准的情况下，代码会变得越来越难维护，一个文件动辄千八百行代码，不用驼峰，不用清晰语义命名，不写代码注释，分分钟逼死强逼症，这样的代码，加个新功能，都要反反复复的翻以前的代码，即使改好了，还有可能因为，之前项目代码不够健壮，报出来其他奇奇怪怪的问题。

## **那前端开发在项目重构中能干点啥呢**

1. 无用的三方库看着不碍眼吗，删掉啊
2. 一些三方库只用了一两次，自写功能成本也不是很高，留着干啥
3. 删除无用变量|无用import 文件
4. 删除用不到的逻辑，精简、抽分通用逻辑
5. 拆分大文件，动辄千八百行的代码文件，不抽分，后期只会越来越多，后期维护成本越来越高，重构代价也越来越大
6. 减少全局样式，采用 css modules 做样式隔离，避免绞尽脑计想命名，也避免跟某个组件库样式冲突
7. 代码结构重构，优化项目工程目录结构，项目迭代下来，会有很多重复的文件目录结构，应该从项目整体角度考虑，合理划分目录结构
8. 代码命名、模块抽分、合理注释总得加一下吧
9. 一些无用的，当时测试用的 console，debugger 看到就删掉呗
10. 做一些必要的依赖升级，项目依赖包一直在升级，为了项目长期稳定的使用依赖包的一些能力，必要的依赖包升级还是有必要的

## **重构时应该注意哪些问题呢**

1. 首先，很认真的问下自己，问下团队相关成员，这个项目是真的需要重构吗，软件迭代是必需的，但是重构真的不是必要的，必要打碎了，重新来过，不一定比之前做的更好
2. 重构时，你要对重构的项目有必要的理解，知道当初这个功能实现的初衷，才能保证重构后的版本，不会有其他不好的影响，建议重构过程中，多看之前的逻辑实现，多问当时参与的人，相关的产品经理、开发，甚至是测试，了解到被注释掉的代码，是否是没用了，真没用了，再扔掉，否则，一刀切，很可能，后期你还得补回来
3. 重构的目的要清楚，你是重构一个组件，一个模块，还是整个系统，整个系统推倒重来，对于任何公司来说都是一个慎重的事情，比较好的做法是，渐进式的重构，把系统切成相互独立的小块，一点一点迭代，可以作为日常迭代，也可以做成专项迭代，看业务需求
4. 架构选型，不一定是什么新，什么流行用什么，得考虑团队或者个人的学习成本，可能这个新技术确实很好，但是现有团队业务开发任务很重，没有必要一步登天，折磨自己，折磨别人，一句话适合自己的才是最好的
5. 明确重构的目的是为了，让项目不像老代码那样臃肿，难以维护，那么定一些标准化的参考规则是很有必要的，最起码保证相当长的时间内，看着像一个正经的项目

## **我个人在重构过程中的一些习惯（仅供参考）**

1. 首先，我会梳理现有项目代码，对照项目页面，给老项目加一点注释标记
2. 创建项目结构 + 功能脑图，项目干了点啥，需要哪些功能一目了然，后期开发，参照起来，安排排期、预估开发进度，个人感觉还挺有用的
3. 标记问题，老项目缺少注释，文件结构混乱是常有的事儿，遇到不理解的，多思多问是个好习惯，提前把风险点记录下来，可以用来评估，这个项目重构带来的结果是不是正向的
4. 参照通用规范，梳理开发标准，像 css、js 的变量命名，模块抽分标准这样还是要有个可参考的开发标准的
5. 基础技术栈统一，一个项目js、ts 混着用，可能是不好的，鉴于现在前端的发展趋势，大方向上使用 ts 会是未来几年的大趋势，也避免了 js 弱类型带来的一些负面影响，样式管理的话，我这边采用的是 less + css module 来做，这样命名相对清晰，也不会造成样式文件相互影响

总后，总结一句话，鞋合不合适，只有脚知道。总不能自己给自己穿小鞋儿是不是。项目重构是不可避免的，但不一定是必要的，没必要为了炫技或者 OKR 来做一些吃力不讨好的事情。

如果你现在也想学习前端开发技术，在学习前端的过程当中有遇见任何关于学习方法，学习路线，学习效率等方面的问题，你都可以申请加入我的Q群[链接](点击链接加入群聊【WEB前端技术学习交流群】：正在跳转)希望能够对你们有所帮助。

# localstorage的一些方法

名称 作用    

 clear 清空localStorage上存储的数据   

getItem 读取数据   

hasOwnProperty 检查localStorage上是否保存了变量x，需要传入x  

 key 读取第i个数据的名字或称为键值(从0开始计数)   

length localStorage存储变量的个数   

propertyIsEnumerable 用来检测属性是否属于某个对象的  

 removeItem 删除某个具体变量  

 setItem 存储数据   

toLocaleString 将（数组）转为本地字符串 

  valueOf 获取所有存储的数据

#  sessionStorage、localStorage和cookie的区别

1）相同点是都是保存在浏览器端、且同源的
2）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
3）存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
4）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
5）作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的
6）web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
7）web Storage的api接口使用更方便


#  前端性能优化

### 1. 减少 HTTP 请求

一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。

### 2. 使用 HTTP2

HTTP2 相比 HTTP1.1 有如下几个优点：

#### 解析速度快

服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。

#### 多路复用

HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。

在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。
多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。

#### 首部压缩

HTTP2 提供了首部压缩功能。

### 3. 使用服务端渲染

客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。

服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

- 优点：首屏渲染快，SEO 好。
- 缺点：配置麻烦，增加了服务器的计算压力。

下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。

#### 客户端渲染过程

1. 访问客户端渲染的网站。
2. 服务器返回一个包含了引入资源语句和 `<div id="app"></div>` 的 HTML 文件。
3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 `new Vue()` 开始实例化并渲染页面。

#### 服务端渲染过程

1. 访问服务端渲染的网站。
2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。
3. 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 `new Vue()` 开始实例化并接管页面。

从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。

### 4. 静态资源使用 CDN

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部

- CSS 执行会阻塞渲染，阻止 JS 执行
- JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建

如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。

###  6. 使用字体图标 iconfont 代替图片图标

字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。

### 7. 善用缓存，不重复加载相同的资源

为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。

不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？

可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。

具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用[数据摘要要算法](https://link.segmentfault.com/?enc=alhl%2BYcz4GymVFFMWrudLw%3D%3D.RNI6Tuf%2BgU7qoBgB91cL0M%2B0I8LHRDpz%2BDwkKAsUkuMUpbmLMvgEkejOqaLMris2fMom3RP5MBLPrvHnKmeRzegOW60vysgAGazPzfXrAye43wSawMtwuMNu416se6lM3tJzRB60HwdCi4N7kEfTBTphc8SDNwIsJt%2B9F9MdvF5MxEj6FU4o%2FZAkoWsmLNtqcvnsQ%2Fe0GjY7Q9uJuTtb8g%3D%3D)对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。

### 8. 压缩文件

压缩文件可以减少文件下载时间，让用户体验性更好。

得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。

 . 图片优化

#### (1). 图片延迟加载

在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。

 (2). 响应式图片

响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。

通过 `picture` 实现

```
<picture>
    <source srcset="banner_w1000.jpg" media="(min-width: 801px)">
    <source srcset="banner_w800.jpg" media="(max-width: 800px)">
    <img src="banner_w800.jpg" alt="">
</picture>
```

通过 `@media` 实现

```
@media (min-width: 769px) {
    .bg {
        background-image: url(bg1080.jpg);
    }
}
@media (max-width: 768px) {
    .bg {
        background-image: url(bg768.jpg);
    }
}
```

 (3). 调整图片大小

例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。

所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。

#### (4). 降低图片质量

例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。

压缩方法有两种，一是通过 webpack 插件 `image-webpack-loader`，二是通过在线网站进行压缩。



#### (5). 尽可能利用 CSS3 效果代替图片

有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。

参考资料：

- [img图片在webpack中使用](https://link.segmentfault.com/?enc=f8nvwgoASVuxryb%2FKm3xPA%3D%3D.OHriFn8hDA0TTFaliggnXpmMGeo4ccvsrnZ20B2s8EfnyVqjn28Vz00ltAn25F2g)

#### (6). 使用 webp 格式的图片

### 9. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码

### 10. 减少重绘重排

### 11. 使用事件委托

### 12. if-else 对比 switch

当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。

### 13. 不要覆盖原生方法

无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。

### 14. 降低 CSS 选择器的复杂性

1. 选择器越短越好。
2. 尽量使用高优先级的选择器，例如 ID 和类选择器。
3. 避免使用通配符 *。