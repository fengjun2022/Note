#设计模式

**单例模式是指在内存中只会创建且仅创建一次对象的设计模式。**在程序中**多次使用同一个对象且作用相同**时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中**创建一个对象**，让所有需要调用的地方都共享这一单例对象。

 单例模式的类型

单例模式有两种类型：

- 懒汉式：在**真正需要使用**对象时才去创建该单例类对象
- 饿汉式：在**类加载**时已经创建好该单例对象，等待被程序使用



**工厂模式**

工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂



- 简单工厂模式（Simple Factory）

简单工厂模式最大的优点在于实现**对象的创建和对象的使用分离**，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂





- 工厂方法模式（Factory Method）



工厂方法模式是对简单工厂的进一步优化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。说的好像挺复杂，简单来说就是解决简单工厂模式存在不方便添加新的类的问题，因为添加新的类以后依然需要修改工厂函数。





 抽象工厂模式(Abstract Factory)

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于**创建型模式**，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的





### 策略模式

- 策略类，策略类封装了具体的算法，并负责具体的计算过程
- 环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类







### 代理模式

代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问

代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象



现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化

使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 `Axios` 的实例来进行 HTTP 的请求，使用拦截器 `interceptor` 可以提前对 请求前的数据 服务器返回的数据进行一些预处理